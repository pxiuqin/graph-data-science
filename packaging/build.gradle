apply plugin: 'java-library'
apply plugin: 'com.github.johnrengelman.shadow'

description = 'Neo4j Graph Data Science :: Packaging'
group = 'com.neo4j.gds'

dependencies {
    implementation project(':proc')
    implementation project(':alpha-embeddings')
}

task licenseFile {
    outputs.file(distributionLicenseFile)
}

task checkLicensesFile {
    dependsOn generateLicensesFiles

    doLast {
        def licenceHeader = rootProject.file("$publicDir/etc/licenses/headers/LICENSES-header.txt").text
        def generatedLicenseFile = file("$buildDir/reports/license/LICENSES.txt").text
        if (generatedLicenseFile.equals(licenceHeader)) {
            throw new GradleException("LICENSES.txt file is empty!")
        }
    }
}

shadowJar {
    dependsOn checkLicensesFile

    mergeServiceFiles()
    archiveBaseName.set("neo4j-graph-data-science")
    archiveClassifier.set("standalone")
    exclude 'META-INF/versions/**/*'
    from licenseFile
    from file("$buildDir/reports/license")
}

task shadowCopy(type: Copy) {
    from(shadowJar)
    into distributionDir
}

task versionsJson {
    ext.outFile = file("$distributionDir/versions.json")
    def bucketUrl = "https://s3-eu-west-1.amazonaws.com/com.neo4j.graphalgorithms.dist/graph-data-science"
    def versionsJsonUrl = new URL("https://s3-eu-west-1.amazonaws.com/com.neo4j.graphalgorithms.dist/graph-data-science/versions.json")
    outputs.file(outFile)
    doLast {
        def versionsJson = new groovy.json.JsonSlurper().parse(versionsJsonUrl)
        def indexedVersionsJson = versionsJson.collectEntries {
            [(it.neo4j): it]
        }

        def neo4jVersions
        if (project.hasProperty('neo4jVersions')) {
            neo4jVersions = project.property('neo4jVersions').split(',')
        } else {
            neo4jVersions = [ver.neo4j]
        }

        def gdsVersion = project.hasProperty('gdsVersion') ? project.property('gdsVersion') : project.version
        def shouldUpdateVersion = gdsVersion.toString().matches("^(\\d+\\.){2}\\d+\$")
        if (shouldUpdateVersion) {
            shadowJar.version = gdsVersion
            neo4jVersions.flatten().forEach { version ->
                indexedVersionsJson[version] = [
                        'neo4j'  : version,
                        'version': gdsVersion,
                        'jar'    : "$bucketUrl/${shadowJar.archiveName}",
                ]
            }

            // Restore shadowJar version
            shadowJar.version = project.version
        }
        outFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(indexedVersionsJson.values()))
    }
}

task docsVersionsJson {
    ext.outFile = file("$distributionDir/doc-versions.json")
    def versionsJsonUrl = new URL("https://s3-eu-west-1.amazonaws.com/com.neo4j.graphalgorithms.dist/graph-data-science/doc-versions.json")
    outputs.file(outFile)
    doLast {
        def versionsJson = new groovy.json.JsonSlurper().parse(versionsJsonUrl)
        def gdsVersion = project.version
        // True if the project version doesn't contain `-alpha0x`
        def isGa = gdsVersion.toString().matches("^(\\d+\\.){2}\\d+\$")

        // Derive the Docs version  from the GDS Version -> i.e.
        // GDS Version: `1.4.0-alpha01` -> `1.4-preview`
        // GDS Version: `1.4.1` -> `1.4`
        def docsVersion = (gdsVersion =~ /(\d+)\.(\d+)/).findAll()*.first()[0]
        if(!isGa) {
            docsVersion += '-preview'
        }

        // Find the index of the element that starts with our new docs version
        // Using `startsWith` to catch new version being GA and the old one Preview
        def idx = versionsJson.findIndexOf { v -> v.startsWith(docsVersion)}
        if(idx >= 0) {
            // Replace the old version it if exists
            versionsJson[idx] = docsVersion
        } else {
            // Add the new docs version if it doesn't exist
            versionsJson.add(docsVersion)
        }

        // Save the results to a file
        outFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(versionsJson))
    }
}

task distZip(type: Zip) {
    description 'Create a ZIP archive of the main distribution JAR.'
    archiveBaseName = shadowJar.archiveBaseName
    archiveClassifier = shadowJar.archiveClassifier
    from shadowJar
    destinationDirectory.set(file(distributionDir))
}

ci.finalizedBy shadowCopy, versionsJson, docsVersionsJson, distZip
cipr.finalizedBy shadowCopy, versionsJson, docsVersionsJson, distZip
